// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`


module pinmux_reg_top (
  input  logic        clk_i,
  input  logic        rst_ni,

  // To HW
  output pinmux_reg_pkg::pinmux_reg2hw_t reg2hw, // Write

  input  logic        reg_we,
  input  logic        reg_re,
  input  logic [31:0] reg_wdata,
  input  logic [ 3:0] reg_be,
  input  logic [31:0] reg_addr,
  output logic [31:0] reg_rdata
);

  import pinmux_reg_pkg::* ;

  localparam int AW = 2;
  localparam int DW = 32;
  localparam int DBW = DW/8;    // Byte Width

  logic reg_error;
  logic addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;

  assign reg_rdata = reg_rdata_next;
  assign reg_error = wr_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic ctrl_we;
  logic [1:0] ctrl_io0_mux_qs;
  logic [1:0] ctrl_io0_mux_wd;
  logic [1:0] ctrl_io1_mux_qs;
  logic [1:0] ctrl_io1_mux_wd;
  logic [1:0] ctrl_io2_mux_qs;
  logic [1:0] ctrl_io2_mux_wd;
  logic [1:0] ctrl_io3_mux_qs;
  logic [1:0] ctrl_io3_mux_wd;
  logic [1:0] ctrl_io4_mux_qs;
  logic [1:0] ctrl_io4_mux_wd;
  logic [1:0] ctrl_io5_mux_qs;
  logic [1:0] ctrl_io5_mux_wd;
  logic [1:0] ctrl_io6_mux_qs;
  logic [1:0] ctrl_io6_mux_wd;
  logic [1:0] ctrl_io7_mux_qs;
  logic [1:0] ctrl_io7_mux_wd;
  logic [1:0] ctrl_io8_mux_qs;
  logic [1:0] ctrl_io8_mux_wd;
  logic [1:0] ctrl_io9_mux_qs;
  logic [1:0] ctrl_io9_mux_wd;
  logic [1:0] ctrl_io10_mux_qs;
  logic [1:0] ctrl_io10_mux_wd;
  logic [1:0] ctrl_io11_mux_qs;
  logic [1:0] ctrl_io11_mux_wd;
  logic [1:0] ctrl_io12_mux_qs;
  logic [1:0] ctrl_io12_mux_wd;
  logic [1:0] ctrl_io13_mux_qs;
  logic [1:0] ctrl_io13_mux_wd;
  logic [1:0] ctrl_io14_mux_qs;
  logic [1:0] ctrl_io14_mux_wd;
  logic [1:0] ctrl_io15_mux_qs;
  logic [1:0] ctrl_io15_mux_wd;

  // Register instances
  // R[ctrl]: V(False)

  //   F[io0_mux]: 1:0
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io0_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io0_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io0_mux.q),

    // to register interface (read)
    .qs     (ctrl_io0_mux_qs)
  );


  //   F[io1_mux]: 3:2
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io1_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io1_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io1_mux.q),

    // to register interface (read)
    .qs     (ctrl_io1_mux_qs)
  );


  //   F[io2_mux]: 5:4
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io2_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io2_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io2_mux.q),

    // to register interface (read)
    .qs     (ctrl_io2_mux_qs)
  );


  //   F[io3_mux]: 7:6
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io3_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io3_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io3_mux.q),

    // to register interface (read)
    .qs     (ctrl_io3_mux_qs)
  );


  //   F[io4_mux]: 9:8
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io4_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io4_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io4_mux.q),

    // to register interface (read)
    .qs     (ctrl_io4_mux_qs)
  );


  //   F[io5_mux]: 11:10
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io5_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io5_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io5_mux.q),

    // to register interface (read)
    .qs     (ctrl_io5_mux_qs)
  );


  //   F[io6_mux]: 13:12
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io6_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io6_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io6_mux.q),

    // to register interface (read)
    .qs     (ctrl_io6_mux_qs)
  );


  //   F[io7_mux]: 15:14
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io7_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io7_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io7_mux.q),

    // to register interface (read)
    .qs     (ctrl_io7_mux_qs)
  );


  //   F[io8_mux]: 17:16
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io8_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io8_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io8_mux.q),

    // to register interface (read)
    .qs     (ctrl_io8_mux_qs)
  );


  //   F[io9_mux]: 19:18
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io9_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io9_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io9_mux.q),

    // to register interface (read)
    .qs     (ctrl_io9_mux_qs)
  );


  //   F[io10_mux]: 21:20
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io10_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io10_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io10_mux.q),

    // to register interface (read)
    .qs     (ctrl_io10_mux_qs)
  );


  //   F[io11_mux]: 23:22
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io11_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io11_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io11_mux.q),

    // to register interface (read)
    .qs     (ctrl_io11_mux_qs)
  );


  //   F[io12_mux]: 25:24
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io12_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io12_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io12_mux.q),

    // to register interface (read)
    .qs     (ctrl_io12_mux_qs)
  );


  //   F[io13_mux]: 27:26
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io13_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io13_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io13_mux.q),

    // to register interface (read)
    .qs     (ctrl_io13_mux_qs)
  );


  //   F[io14_mux]: 29:28
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io14_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io14_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io14_mux.q),

    // to register interface (read)
    .qs     (ctrl_io14_mux_qs)
  );


  //   F[io15_mux]: 31:30
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_ctrl_io15_mux (
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),

    // from register interface
    .we     (ctrl_we),
    .wd     (ctrl_io15_mux_wd),

    // from internal hardware
    .de     (1'b0),
    .d      ('0),

    // to internal hardware
    .qe     (),
    .q      (reg2hw.ctrl.io15_mux.q),

    // to register interface (read)
    .qs     (ctrl_io15_mux_qs)
  );


  logic [0:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[0] = (reg_addr == PINMUX_CTRL_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[0] & (|(PINMUX_PERMIT[0] & ~reg_be)))));
  end

  assign ctrl_we = addr_hit[0] & reg_we & !reg_error;

  assign ctrl_io0_mux_wd = reg_wdata[1:0];

  assign ctrl_io1_mux_wd = reg_wdata[3:2];

  assign ctrl_io2_mux_wd = reg_wdata[5:4];

  assign ctrl_io3_mux_wd = reg_wdata[7:6];

  assign ctrl_io4_mux_wd = reg_wdata[9:8];

  assign ctrl_io5_mux_wd = reg_wdata[11:10];

  assign ctrl_io6_mux_wd = reg_wdata[13:12];

  assign ctrl_io7_mux_wd = reg_wdata[15:14];

  assign ctrl_io8_mux_wd = reg_wdata[17:16];

  assign ctrl_io9_mux_wd = reg_wdata[19:18];

  assign ctrl_io10_mux_wd = reg_wdata[21:20];

  assign ctrl_io11_mux_wd = reg_wdata[23:22];

  assign ctrl_io12_mux_wd = reg_wdata[25:24];

  assign ctrl_io13_mux_wd = reg_wdata[27:26];

  assign ctrl_io14_mux_wd = reg_wdata[29:28];

  assign ctrl_io15_mux_wd = reg_wdata[31:30];

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[1:0] = ctrl_io0_mux_qs;
        reg_rdata_next[3:2] = ctrl_io1_mux_qs;
        reg_rdata_next[5:4] = ctrl_io2_mux_qs;
        reg_rdata_next[7:6] = ctrl_io3_mux_qs;
        reg_rdata_next[9:8] = ctrl_io4_mux_qs;
        reg_rdata_next[11:10] = ctrl_io5_mux_qs;
        reg_rdata_next[13:12] = ctrl_io6_mux_qs;
        reg_rdata_next[15:14] = ctrl_io7_mux_qs;
        reg_rdata_next[17:16] = ctrl_io8_mux_qs;
        reg_rdata_next[19:18] = ctrl_io9_mux_qs;
        reg_rdata_next[21:20] = ctrl_io10_mux_qs;
        reg_rdata_next[23:22] = ctrl_io11_mux_qs;
        reg_rdata_next[25:24] = ctrl_io12_mux_qs;
        reg_rdata_next[27:26] = ctrl_io13_mux_qs;
        reg_rdata_next[29:28] = ctrl_io14_mux_qs;
        reg_rdata_next[31:30] = ctrl_io15_mux_qs;
      end

      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

endmodule
